(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{681:function(e,s,n){"use strict";n.r(s);var t=n(6),a=Object(t.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("大家都听说过 http 的"),n("code",[e._v("keep-alive")]),e._v(", 不过 TCP 层面也是有"),n("code",[e._v("keep-alive")]),e._v("机制，而且跟应用层不太一样。")]),e._v(" "),n("p",[e._v("试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。")]),e._v(" "),n("p",[e._v("这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。")]),e._v(" "),n("p",[e._v("在 Linux 下，可以这样查看相关的配置:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br")])]),n("p",[e._v("不过，现状是大部分的应用并没有默认开启 TCP 的"),n("code",[e._v("keep-alive")]),e._v("选项，为什么？")]),e._v(" "),n("p",[e._v("站在应用的角度:")]),e._v(" "),n("ul",[n("li",[e._v("7200s 也就是两个小时检测一次，时间太长")]),e._v(" "),n("li",[e._v("时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接")])]),e._v(" "),n("p",[e._v("因此是一个比较尴尬的设计。")])])}),[],!1,null,null,null);s.default=a.exports}}]);